//=============================================================================
//
// 攻撃種類 [attack.cpp]
// Author : 吉田悠人
//
//=============================================================================
//=============================================================================
// ヘッダファイルのインクルード
//=============================================================================
#include "attack.h"
#include "tile.h"
#include "resource_attack.h"
#include "player.h"
#include "bullet.h"

//=============================================================================
// コンストラクタ
//=============================================================================
CAttackBased::CAttackBased()
{
	//初期化処理
	m_nAttackType = CAttackManager::ATTACK_TYPE_1;
	m_pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	memset(&m_AttackSquare, 0, sizeof(CAttackManager::ATTACK_SQUARE_DATA));
	m_bAttack = false;
	m_pPlayer = NULL;

}

//=============================================================================
// デストラクタ
//=============================================================================
CAttackBased::~CAttackBased()
{
}

//=============================================================================
// 初期化関数
//=============================================================================
HRESULT CAttackBased::Init(void)
{
	//攻撃タイプセット
	m_AttackSquare = CAttackManager::GetAttack(m_nAttackType);
	return S_OK;
}

//=============================================================================
// 終了関数
//=============================================================================
void CAttackBased::Uninit(void)
{
	//オブジェクトの破棄
	Release();
}

//=============================================================================
// 更新関数
//=============================================================================
void CAttackBased::Update(void)
{
}

//=============================================================================
// 描画関数
//=============================================================================
void CAttackBased::Draw(void)
{
}

//=============================================================================
// 攻撃タイプセッター関数
//=============================================================================
void CAttackBased::SetAttackType(CAttackManager::ATTACK_TYPE AttackType)
{
	m_nAttackType = AttackType;
}

//=============================================================================
// 攻撃タイプゲッター関数
//=============================================================================
CAttackManager::ATTACK_TYPE CAttackBased::GetAttackType(void)
{
	return m_nAttackType;
}

//=============================================================================
// 撃マスデータゲッター関数
//=============================================================================
void CAttackBased::SetAttackSquare(CAttackManager::ATTACK_SQUARE_DATA AttackSquare)
{
	m_AttackSquare = AttackSquare;
}

//=============================================================================
// 撃マスデータゲッター関数
//=============================================================================
CAttackManager::ATTACK_SQUARE_DATA CAttackBased::GetAttackSquare(void)
{
	return m_AttackSquare;
}

//=============================================================================
// 位置セッター関数
//=============================================================================
void CAttackBased::SetPos(D3DXVECTOR3 pos)
{
	m_pos = pos;
}

//=============================================================================
// 位置ゲッター関数
//=============================================================================
D3DXVECTOR3 CAttackBased::GetPos(void)
{
	return m_pos;
}

//=============================================================================
// 向きセッター関数
//=============================================================================
void CAttackBased::SetRot(D3DXVECTOR3 rot)
{
	m_rot = rot;
}

//=============================================================================
// 向きゲッター関数
//=============================================================================
D3DXVECTOR3 CAttackBased::GetRot(void)
{
	return m_rot;
}

//=============================================================================
// 攻撃フラグセッター関数
//=============================================================================
void CAttackBased::SetAttackFlag(bool bAttack)
{
	m_bAttack = bAttack;
}

//=============================================================================
// 攻撃スイッチ関数
//=============================================================================
void CAttackBased::AttackSwitch(void)
{
	//攻撃されていなかったら
	if (!m_bAttack)
	{
		//フラグオン
		SetAttackFlag(true);
		//位置取得
		SetPos(m_pPlayer->GetPos());
		//向き取得
		SetRot(m_pPlayer->GetRot());
	}
}

//=============================================================================
// 攻撃フラグゲッター関数
//=============================================================================
bool CAttackBased::GetAttackFlag(void)
{
	return m_bAttack;
}

//=============================================================================
// プレイヤーポインタゲッター関数
//=============================================================================
void CAttackBased::SetPlayer(CPlayer * pPlayer)
{
	m_pPlayer = pPlayer;
}

//=============================================================================
// プレイヤーポインタゲッター関数
//=============================================================================
CPlayer * CAttackBased::GetPlayer(void)
{
	return m_pPlayer;
}

//=============================================================================
// 攻撃関数
//=============================================================================
void CAttackBased::Attack(CAttackManager::ATTACK_RANGE_TYPE AttackType)
{
	for (int nAttack = 0; nAttack<m_AttackSquare.m_nMaxHitRange; nAttack++)
	{
		//タイプが一致しているか
		if (m_AttackSquare.m_SquareData[nAttack].m_RangeType == AttackType)
		{
			//行列計算
			D3DXVECTOR3 CreatePos;
			//攻撃位置
			D3DXVECTOR3 AttackPos = m_AttackSquare.m_SquareData[nAttack].m_AttackPos * TILE_ONE_SIDE;
			CreatePos.x = ((cosf(m_rot.y + D3DXToRadian(90.0f))*AttackPos.x) + (sinf(m_rot.y + D3DXToRadian(90.0f))*AttackPos.z));
			CreatePos.y = 1 * AttackPos.y;
			CreatePos.z = ((-sinf(m_rot.y + D3DXToRadian(90.0f))*AttackPos.x) + (cosf(m_rot.y + D3DXToRadian(90.0f))*AttackPos.z));
			//当たり判定生成
			CBullet::Create(CreatePos + m_pos, D3DXVECTOR3(0.0f, 0.0f, 0.0f), m_pPlayer->GetPlayerNumber());
		}
	}
}
